## Avaliações por mês
time_analysis <- ratings %>%
mutate(month = month(date, label = TRUE)) %>%
count(month) %>%
arrange(desc(n))
mutate(month = month(date) %>%
## Avaliações por mês
time_analysis <- ratings %>%
## Avaliações por mês
time_analysis <- ratings %>%
mutate(month = month(date)) %>%
count(month) %>%
arrange(desc(n))
## Avaliações por mês
time_analysis <- ratings %>%
time_analysis <- ratings %>%
mutate(month = month(date)) %>%
count(month) %>%
arrange(desc(n))
print(time_analysis)
time_analysis <- time_analysis %>%
mutate(month = factor(month, levels = 1:12, labels = month.abb))
print(time_analysis)
## Clustering de usuários
user_profiles <- ratings %>%
group_by(user_id) %>%
summarise(avg_rating = mean(rating), total_ratings = n(), .groups = 'drop')
set.seed(123)
kmeans_result <- kmeans(user_profiles[, c("avg_rating", "total_ratings")], centers = 3)
user_profiles$cluster <- kmeans_result$cluster
print(user_profiles)
## Influência do volume de avaliações na nota média
correlation <- cor(user_profiles$total_ratings, user_profiles$avg_rating)
print(correlation)
## Criar matriz de avaliações
rating_matrix <- ratings %>%
select(user_id, movie_id, rating) %>%
pivot_wider(names_from = movie_id, values_from = rating) %>%
column_to_rownames("user_id") %>%
as.matrix()
rating_matrix <- as(rating_matrix, "realRatingMatrix")
## Criar modelo de filtragem colaborativa
recommender_model <- Recommender(rating_matrix, method = "UBCF")
recommendations <- predict(recommender_model, rating_matrix[1:5, ], n = 5)
print(recommendations)
# Exibir resultados
list(
genre_means = genre_means,
time_ratings = time_ratings,
genre_counts = genre_counts,
time_reviews = time_reviews,
user_clusters = table(user_profiles$cluster),
user_review_stats = user_review_stats,
recommendations = as(predictions, "list")
)
# Exibir resultados
list(
genre_popularity = genre_popularity,
time_ratings = time_ratings,
genre_counts = genre_counts,
time_reviews = time_reviews,
user_clusters = table(user_profiles$cluster),
user_review_stats = user_review_stats,
recommendations = as(predictions, "list")
)
# Exibir resultados
list(
genre_popularity = genre_popularity,
time_analysis = time_analysis,
genre_counts = genre_counts,
time_reviews = time_reviews,
user_clusters = table(user_profiles$cluster),
user_review_stats = user_review_stats,
recommendations = as(predictions, "list")
)
# Exibir resultados
list(
genre_ratings = genre_ratings,
time_analysis = time_analysis,
genre_popularity = genre_popularity,
time_reviews = time_reviews,
user_clusters = table(user_profiles$cluster),
user_review_stats = user_review_stats,
recommendations = as(predictions, "list")
)
# Exibir resultados
list(
genre_ratings = genre_ratings,
temporal_ratings = temporal_ratings,
genre_popularity = genre_popularity,
time_analysis = time_analysis,
user_clusters = table(user_profiles$cluster),
user_review_stats = user_review_stats,
recommendations = as(predictions, "list")
)
# Exibir resultados
list(
genre_ratings = genre_ratings,
temporal_ratings = temporal_ratings,
genre_popularity = genre_popularity,
time_analysis = time_analysis,
user_profiles = table(user_profiles$cluster),
rating_matrix = rating_matrix,
recommendations = as(predictions, "list")
)
# Exibir resultados
list(
genre_ratings = genre_ratings,
temporal_ratings = temporal_ratings,
genre_popularity = genre_popularity,
time_analysis = time_analysis,
user_profiles = table(user_profiles$cluster),
rating_matrix = rating_matrix,
recommendations = as(recommendations, "list")
)
recommendations
# Criar uma função para mapear IDs para títulos
get_movie_titles <- function(movie_ids, movies_df) {
titles <- movies_df %>%
filter(movieId %in% as.numeric(movie_ids)) %>%
pull(title)
return(titles)
}
get_movie_titles
# Aplicar a função às recomendações
recommendations_named <- lapply(recommendations, get_movie_titles, movies_df = movies)
View(movies)
View(movies_long)
# Converter recommendations para uma lista simples
recommendations_list <- as(recommendations, "list")
# Criar a função de mapeamento para os títulos dos filmes
get_movie_titles <- function(movie_ids, movies_df) {
titles <- movies_df %>%
filter(movieId %in% as.numeric(movie_ids)) %>%
pull(title)
return(titles)
}
# Aplicar a função às recomendações corrigidas
recommendations_named <- lapply(recommendations_list, get_movie_titles, movies_df = movies)
# Criar a função de mapeamento para os títulos dos filmes
get_movie_titles <- function(movie_ids, movies_df) {
titles <- movies_df %>%
filter(movie_id %in% as.numeric(movie_ids)) %>%
pull(title)
return(titles)
}
# Aplicar a função às recomendações corrigidas
recommendations_named <- lapply(recommendations_list, get_movie_titles, movies_df = movies)
# Exibir as recomendações com nomes dos filmes
recommendations_named
# Criar um dataframe associando usuários e recomendações
user_recommendations <- data.frame(
user_id = names(recommendations),
recommended_movies = I(recommendations)
)
# Criar um dataframe associando usuários e recomendações
user_recommendations <- data.frame(
user_id = names(recommendations_list),
recommended_movies = I(recommendations_list)
)
# Juntar com os clusters
user_recommendations <- user_recommendations %>%
left_join(user_profiles, by = "user_id")
user_recommendations
# Juntar com os clusters
user_recommendations <- user_recommendations %>%
left_join(user_profiles, by = "user_id")
View(user_recommendations)
View(user_profiles)
# Juntar com os clusters
user_profiles <- user_profiles %>%
mutate(user_id = as.character(user_id))
user_recommendations <- user_recommendations %>%
left_join(user_profiles, by = "user_id")
user_recommendations
recommendations
# Exibir resultados
list(
genre_ratings = genre_ratings,
temporal_ratings = temporal_ratings,
genre_popularity = genre_popularity,
time_analysis = time_analysis,
user_profiles = table(user_profiles$cluster),
rating_matrix = rating_matrix,
recommendations = as(recommendations, "list")
)
names(recommendations) <- as.character(1:length(recommendations))
names(recommendations_list) <- as.character(1:length(recommendations_list))
recommendations_list
# Criar a função de mapeamento para os títulos dos filmes
get_movie_titles <- function(movie_ids, movies_df) {
titles <- movies_df %>%
filter(movie_id %in% as.numeric(movie_ids)) %>%
pull(title)
return(titles)
}
# Aplicar a função às recomendações corrigidas
recommendations_named <- lapply(recommendations_list, get_movie_titles, movies_df = movies)
# Exibir as recomendações com nomes dos filmes
recommendations_named
# Criar um dataframe associando usuários e recomendações
user_recommendations <- data.frame(
user_id = names(recommendations_list),
recommended_movies = I(recommendations_list)
)
# Juntar com os clusters
user_profiles <- user_profiles %>%
mutate(user_id = as.character(user_id))
user_recommendations <- user_recommendations %>%
left_join(user_profiles, by = "user_id")
# Comparar recomendações por cluster
recommendations_by_cluster <- user_recommendations %>%
group_by(cluster) %>%
summarize(recommended_movies = list(unique(unlist(recommended_movies))))
# Exibir os filmes recomendados para cada cluster
print(recommendations_by_cluster)
user_recommendations
recommendations_by_cluster
View(recommendations_by_cluster)
print(recommendations)
# Definir caminho dos dados
data_path <- "data/"
# Carregar os dados
ratings <- fread(file.path(data_path, "u.data"), col.names = c("user_id", "movie_id", "rating", "timestamp"))
movies <- fread(file.path(data_path, "u.item"), sep = "|", header = FALSE, encoding = "Latin-1",
select = c(1, 2, 6:24), col.names = c("movie_id", "title", paste0("genre_", 1:19)))
# Converter timestamp para data
ratings <- ratings %>%
mutate(date = as_datetime(timestamp))
# Criar um dataframe de gêneros
movies_long <- movies %>%
pivot_longer(cols = starts_with("genre_"), names_to = "genre", values_to = "has_genre") %>%
filter(has_genre == 1) %>%
select(movie_id, title, genre) %>%
mutate(genre = str_replace(genre, "genre_", ""))
# Mapear códigos de gênero para nomes
genre_mapping <- c("Unknown", "Action", "Adventure", "Animation", "Children", "Comedy", "Crime",
"Documentary", "Drama", "Fantasy", "Film-Noir", "Horror", "Musical", "Mystery",
"Romance", "Sci-Fi", "Thriller", "War", "Western")
movies_long$genre <- genre_mapping[as.numeric(movies_long$genre)]
# Agregar avaliações por filme
ratings_agg <- ratings %>%
group_by(movie_id) %>%
summarise(avg_rating = mean(rating), total_ratings = n(), .groups = 'drop')
# Juntar avaliações com gêneros
ratings_genre <- ratings %>%
inner_join(movies_long, by = "movie_id") %>%
select(movie_id, user_id, rating, genre)
# Juntar avaliações com gêneros
ratings_genre <- ratings %>%
inner_join(movies_long, by = "movie_id", relationship = "many-to-many") %>%
select(movie_id, user_id, rating, genre)
# 1. Padrões de avaliação
## Médias de avaliação por gênero
genre_ratings <- ratings_genre %>%
group_by(genre) %>%
summarise(avg_rating = mean(rating, na.rm = TRUE), .groups = 'drop') %>%
arrange(desc(avg_rating))
# Gráfico de média de avaliações por gênero
ggplot(genre_ratings, aes(x = reorder(genre, -avg_rating), y = avg_rating)) +
geom_col(fill = "steelblue") +
coord_flip() +
labs(title = "Média de Avaliações por Gênero", x = "Gênero", y = "Média de Avaliação")
# Gráfico de média de avaliações por gênero
ggplot(genre_ratings, aes(x = reorder(genre, -avg_rating), y = avg_rating)) +
geom_col(fill = "skyblue") +
coord_flip() +
labs(title = "Média de Avaliações por Gênero", x = "Gênero", y = "Média de Avaliação")
steel
# Gráfico de média de avaliações por gênero
ggplot(genre_ratings, aes(x = reorder(genre, -avg_rating), y = avg_rating)) +
geom_col(fill = "steelblue") +
coord_flip() +
labs(title = "Média de Avaliações por Gênero", x = "Gênero", y = "Média de Avaliação")
## Distribuição de notas ao longo do tempo
temporal_ratings <- ratings %>%
mutate(year = year(date), month = month(date, label = TRUE)) %>%
group_by(year, month) %>%
summarise(avg_rating = mean(rating), .groups = 'drop')
## Distribuição de notas ao longo do tempo
temporal_ratings <- ratings %>%
mutate(year = year(date), month = factor(month, levels = 1:12, labels = month.abb)) %>%
group_by(year, month) %>%
summarise(avg_rating = mean(rating), .groups = 'drop')
## Distribuição de notas ao longo do tempo
temporal_ratings <- ratings %>%
mutate(year = year(date), month = month(date)) %>%
group_by(year, month) %>%
summarise(avg_rating = mean(rating), .groups = 'drop')
temporal_ratings <- temporal_ratings %>%
mutate(month = factor(month, levels = 1:12, labels = month.abb))
# 2. Padrões de consumo
## Quantidade de avaliações por gênero
genre_popularity <- ratings_genre %>%
count(genre, sort = TRUE)
# Gráfico de popularidade por gênero
ggplot(genre_popularity, aes(x = reorder(genre, -n), y = n)) +
geom_col(fill = "darkorange") +
coord_flip() +
labs(title = "Número de Avaliações por Gênero", x = "Gênero", y = "Número de Avaliações")
## Avaliações por mês
time_analysis <- ratings %>%
mutate(month = month(date, label = TRUE)) %>%
count(month)
## Avaliações por mês
time_analysis <- ratings %>%
mutate(month = month(date)) %>%
count(month) %>%
arrange(desc(n))
time_analysis <- time_analysis %>%
mutate(month = factor(month, levels = 1:12, labels = month.abb))
# 3. Perfis de usuários
## Clustering de usuários
user_profiles <- ratings %>%
group_by(user_id) %>%
summarise(avg_rating = mean(rating), total_ratings = n(), .groups = 'drop')
set.seed(123)
kmeans_result <- kmeans(user_profiles[, c("avg_rating", "total_ratings")], centers = 3)
user_profiles$cluster <- kmeans_result$cluster
# 4. Modelo de recomendação
## Criar matriz de avaliações
rating_matrix <- ratings %>%
select(user_id, movie_id, rating) %>%
pivot_wider(names_from = movie_id, values_from = rating) %>%
column_to_rownames("user_id") %>%
as.matrix()
rating_matrix <- as(rating_matrix, "realRatingMatrix")
## Criar modelo de recomendação
recommender_model <- Recommender(rating_matrix, method = "UBCF")
recommendations <- predict(recommender_model, rating_matrix[1:5, ], n = 5)
recommendations_list <- as(recommendations, "list")
names(recommendations_list) <- as.character(1:length(recommendations_list))
# Criar função para mapear títulos de filmes
get_movie_titles <- function(movie_ids, movies_df) {
titles <- movies_df %>%
filter(movie_id %in% as.numeric(movie_ids)) %>%
pull(title)
return(titles)
}
# Aplicar a função de mapeamento
recommendations_named <- lapply(recommendations_list, get_movie_titles, movies_df = movies)
# Criar dataframe de recomendações
user_recommendations <- data.frame(
user_id = names(recommendations_list),
recommended_movies = I(recommendations_list)
)
# Juntar com perfis de usuário
user_profiles <- user_profiles %>%
mutate(user_id = as.character(user_id))
user_recommendations <- user_recommendations %>%
left_join(user_profiles, by = "user_id")
# Comparar recomendações por cluster
recommendations_by_cluster <- user_recommendations %>%
group_by(cluster) %>%
summarize(recommended_movies = list(unique(unlist(recommended_movies))))
print(recommendations_by_cluster)
user_recommendations
pacman::p_load(tidyverse, data.table, lubridate, recommenderlab, ggplot2, gridExtra)
grid.table(user_recommendations)
user_recommendations
grid.table(user_recommendations)
user_recommendations <- user_recommendations %>%
mutate(recommended_movies = sapply(recommended_movies, function(x) paste(x, collapse = ", ")))
grid.table(user_recommendations)
grid.table(user_recommendations)
rating_matrix
user_recommendations
recommendations_named
rmarkdown::render("notebooks/exploratory.Rmd")
setwd("~/CASES/sistema_recomendacao/scripts/notebooks")
rmarkdown::render("exploratory.Rmd")
rmarkdown::render("scripts/notebooks/exploratory.Rmd")
setwd("~/CASES/sistema_recomendacao")
rmarkdown::render("scripts/notebooks/exploratory.Rmd")
rmarkdown::render("scripts/notebooks/exploratory.Rmd")
# Instalar pacotes caso não estejam instalados
if (!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, recommenderlab, ggplot2)
# Carregar os dados brutos
ratings <- read.table("data/u.data", sep="\t", header=FALSE, col.names=c("user_id", "movie_id", "rating", "timestamp"))
# Carregar os dados brutos
ratings <- fread(file.path("data/", "u.data"), col.names = c("user_id", "movie_id", "rating", "timestamp"))
# Instalar pacotes caso não estejam instalados
if (!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, recommenderlab, ggplot2, data.table)
# Carregar os dados brutos
ratings <- fread(file.path("data/", "u.data"), col.names = c("user_id", "movie_id", "rating", "timestamp"))
# Carregar os dados brutos
ratings <- fread(file.path("data", "u.data"), col.names = c("user_id", "movie_id", "rating", "timestamp"))
setwd("~/CASES/sistema_recomendacao")
# Carregar os dados brutos
ratings <- fread(file.path("data", "u.data"), col.names = c("user_id", "movie_id", "rating", "timestamp"))
# Carregar os dados brutos
setwd('C:/Users/thiag/OneDrive/Documentos/CASES/sistema_recomendacao')
# Carregar os dados brutos
ratings <- fread(file.path("data", "u.data"), col.names = c("user_id", "movie_id", "rating", "timestamp"))
# Instalar pacotes caso não estejam instalados
if (!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, recommenderlab, ggplot2)
# Carregar os dados brutos
ratings <- read.table("data/u.data", sep="\t", header=FALSE, col.names=c("user_id", "movie_id", "rating", "timestamp"))
# Carregar os dados brutos
ratings <- read.table("data/raw/u.data", sep="\t", header=FALSE, col.names=c("user_id", "movie_id", "rating", "timestamp"))
# Carregar os dados brutos
ratings <- read.table("data/raw/u.data", sep="\t", header=FALSE, col.names=c("user_id", "movie_id", "rating", "timestamp"))
# Carregar os dados brutos
ratings <- fread("data/raw/u.data", sep="\t", col.names=c("user_id", "movie_id", "rating", "timestamp"))
setwd("scripts/notebooks/data/raw")
# Carregar os dados brutos
ratings <- fread("scripts/notebooks/data/raw/u.data", sep="\t", col.names=c("user_id", "movie_id", "rating", "timestamp"))
setwd("C:/Users/thiag/OneDrive/Documentos/CASES/sistema_recomendacao/scripts")
# Carregar os dados brutos
ratings <- fread("data/raw/u.data", sep="\t", col.names=c("user_id", "movie_id", "rating", "timestamp"))
setwd("C:/Users/thiag/OneDrive/Documentos/CASES/sistema_recomendacao/scripts")
setwd("C:/Users/thiag/OneDrive/Documentos/CASES/sistema_recomendacao/scripts")
# Carregar os dados brutos
ratings <- fread("data/raw/u.data", sep="\t", col.names=c("user_id", "movie_id", "rating", "timestamp"))
setwd("C:/Users/thiag/OneDrive/Documentos/CASES/sistema_recomendacao/scripts")
setwd("C:/Users/thiag/OneDrive/Documentos/CASES/sistema_recomendacao/scripts")
setwd("~/CASES/sistema_recomendacao")
# 📦 Carregar pacotes
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, data.table, lubridate, ggplot2, cluster, scales)
# 📁 Carregar os dados
ratings <- fread("data/raw/u.data", col.names = c("user_id", "movie_id", "rating", "timestamp"))
# 📦 Carregar pacotes
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, data.table, lubridate, ggplot2, cluster, scales)
# 📁 Carregar os dados
ratings <- fread("dados/u.data", col.names = c("user_id", "movie_id", "rating", "timestamp"))
movies <- fread("dados/u.item", sep = "|", header = FALSE, encoding = "Latin-1",
select = c(1, 2, 6:24), col.names = c("movie_id", "title", paste0("genre_", 1:19)))
# 🕓 Converter timestamp
ratings <- ratings %>%
mutate(date = as_datetime(timestamp))
# 🎭 Gêneros em formato longo
movies_long <- movies %>%
pivot_longer(cols = starts_with("genre_"), names_to = "genre", values_to = "has_genre") %>%
filter(has_genre == 1) %>%
select(movie_id, title, genre) %>%
mutate(genre = str_replace(genre, "genre_", ""))
genre_mapping <- c("Unknown", "Action", "Adventure", "Animation", "Children", "Comedy", "Crime",
"Documentary", "Drama", "Fantasy", "Film-Noir", "Horror", "Musical", "Mystery",
"Romance", "Sci-Fi", "Thriller", "War", "Western")
movies_long$genre <- genre_mapping[as.numeric(movies_long$genre)]
# 🔗 Juntar ratings com gêneros
ratings_genre <- ratings %>%
inner_join(movies_long, by = "movie_id")
# 📊 Análise 1: Média de avaliação por gênero
genre_ratings <- ratings_genre %>%
group_by(genre) %>%
summarise(avg_rating = mean(rating), .groups = 'drop') %>%
arrange(desc(avg_rating))
ggplot(genre_ratings, aes(x = reorder(genre, avg_rating), y = avg_rating)) +
geom_col(fill = "steelblue") +
coord_flip() +
labs(title = "Média de Avaliações por Gênero", x = "Gênero", y = "Média") +
theme_minimal()
# 📈 Análise 2: Evolução da média das avaliações ao longo do tempo
temporal_ratings <- ratings %>%
mutate(date = floor_date(date, unit = "month")) %>%
group_by(date) %>%
summarise(avg_rating = mean(rating), .groups = 'drop')
ggplot(temporal_ratings, aes(x = date, y = avg_rating)) +
geom_line(color = "darkgreen") +
geom_smooth(method = "loess", se = FALSE, color = "black", linetype = "dashed") +
labs(title = "Média de Avaliação ao Longo do Tempo", x = "Data", y = "Média") +
scale_x_datetime(date_labels = "%b/%y", date_breaks = "3 months") +
theme_minimal()
# 📈 Análise 3: Popularidade por gênero
genre_popularity <- ratings_genre %>%
count(genre, sort = TRUE)
ggplot(genre_popularity, aes(x = reorder(genre, n), y = n)) +
geom_col(fill = "darkorange") +
coord_flip() +
labs(title = "Popularidade por Gênero", x = "Gênero", y = "Número de Avaliações") +
theme_minimal()
# 🧪 Análise 4: Distribuição das avaliações
ggplot(ratings, aes(x = rating)) +
geom_bar(fill = "purple", alpha = 0.7) +
labs(title = "Distribuição das Notas", x = "Nota", y = "Frequência") +
theme_minimal()
# 👤 Análise 5: Perfis de usuários
user_profiles <- ratings_genre %>%
group_by(user_id) %>%
summarise(
avg_rating = mean(rating),
sd_rating = sd(rating),
total_ratings = n(),
n_genres = n_distinct(genre),
.groups = 'drop'
) %>%
replace_na(list(sd_rating = 0))
# 🤖 Clustering de usuários (K-means)
set.seed(123)
kmeans_result <- kmeans(user_profiles[, c("avg_rating", "sd_rating", "total_ratings", "n_genres")], centers = 3)
user_profiles$cluster <- as.factor(kmeans_result$cluster)
# 📊 Visualização dos clusters
ggplot(user_profiles, aes(x = avg_rating, y = total_ratings, color = cluster)) +
geom_point(alpha = 0.7) +
labs(title = "Clusters de Usuários", x = "Média de Avaliação", y = "Total de Avaliações") +
theme_minimal()
# 🧠 Análise por cluster
cluster_summary <- user_profiles %>%
group_by(cluster) %>%
summarise(across(c(avg_rating, sd_rating, total_ratings, n_genres), mean), .groups = 'drop')
print(cluster_summary)
# 💥 Outliers: usuários com comportamento extremo
ratings_extremos <- user_profiles %>%
filter(avg_rating == 5 | avg_rating == 1) %>%
arrange(desc(total_ratings))
print(head(ratings_extremos))
